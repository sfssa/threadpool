# C++实现高性能线程池

#  线程池的瓶颈

一个线程池的限制因素多种多样，线程池的设计细节、适用场景、具体的执行任务等都会成为线程池性能的瓶颈。以下是一些基本的线程池性能限制因素：

## 线程池的数量

计算机在执行程序时可以简单的分为两种：CPU密集型和IO密集型。

![image-20231128145157772](https://github.com/sfssa/threadpool/blob/master/static/threadNums.png)

### CPU密集型

CPU密集型需要长时间占用CPU来完成计算的任务。CPU密集型任务是指主要消耗CPU计算资源的任务，执行过程中大部分时间都在执行计算、逻辑判断等操作。不需要等待外部资源（磁盘IO，网路IO）的操作。不涉及大量的等待时间，大部分时间都用来执行计算指令。

利用线程池解决CPU密集型任务时，假设计算机是N核处理器，那么通常将线程数量设置为：N/(N+1)。假设线程池数量为N，那么可以确保每一个处理器都在执行计算任务，但是如果某一个线程因为某种原因导致暂停了，那么此时就会有一个处理器空闲下来，因此经过测试发现，将线程池数量设置为N+1，的情况下，即使某个线程因为某些原因出现了问题，那么也可以保证另外四个线程的执行，保证每个处理器都被充分利用。

针对上面的公式：也就是等待时间很短，W/C趋近于0，CPU利用率达到1，也即是N。

当然，也有人会问，那么如果有两个线程都被暂停了呢？甚至四个线程都被暂停了呢？是否要设置为N+N？事实上，不要忘记了线程之间的切换也是会降低线程池的性能的。通过测试，发现N+1时性能非常好。

### IO密集型

IO密集型任务是指在执行过程中主要涉及到等待输入/输出操作的任务，这类人物的特点是在执行过程中需要频繁的进行IO操作。如文件读写、网络通信、数据库查询等。这些操作比较耗时，但是占用CPU时间很短。通常可以用异步编程、非阻塞IO等技术提高系统的性能和响应速度。

针对上面的公式：也就是等待时间和计算时间趋近，CPU利用率按1处理，得到2N。

## 线程间同步开销

## 线程间通信开销

## 任务队列的阻塞

## 任务队列的执行时间

## 任务队列的调度算法

## 错误处理和异常处理

## 硬件资源
